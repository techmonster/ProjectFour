/**   A modified class that represents an infix and postfix expression.   Based on pseudocode in Segments 5.16 and 5.18.   @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class Postfix{   public static String convertToInfix(String infix) {      StackInterface<Character> operatorStack = new LinkedStack<Character>();      StringBuilder infixExpression = new StringBuilder();      int characterCount = infix.length();      char topOperator;      for (int index = 0; index < characterCount; index++) {         char nextCharacter = infix.charAt(index);         if (isInteger(nextCharacter)) {            nextCharacter = characterChange(nextCharacter);            infixExpression.append(nextCharacter);         }         else {            switch (nextCharacter)            {               case 'a': case 'b': case 'c': case 'd': case 'e':case 'f': case 'g':case 'h':               infixExpression.append(nextCharacter);               break;               case '^':               infixExpression.append(nextCharacter);               break;               case '+': case '-': case '*': case '/':               infixExpression.append(nextCharacter);               break;               case '(':                  infixExpression.append(nextCharacter);                  break;               case ')': // Stack is not empty if infix expression is valid                  infixExpression.append(nextCharacter);                  break;               default: break; // Ignore unexpected characters            } // end switch         } // end if      } // end for      while (!operatorStack.isEmpty())      {         topOperator = operatorStack.pop();         infixExpression = infixExpression.append(topOperator);      } // end while      return infixExpression.toString();   } // end convertToPostfix   /** Creates a postfix expression that represents a given infix expression.       Segment 5.16.       @param infix  A string that is a valid infix expression.       @return  A string that is the postfix expression equivalent to infix. */   public static String convertToPostfix(String infix)   {      StackInterface<Character> operatorStack = new LinkedStack<Character>();      StringBuilder postfix = new StringBuilder();      int characterCount = infix.length();      char topOperator;      for (int index = 0; index < characterCount; index++)      {         boolean done = false;         char nextCharacter = infix.charAt(index);         if (isVariable(nextCharacter))            postfix = postfix.append(nextCharacter);         else         {            switch (nextCharacter)            {               case '^':                  operatorStack.push(nextCharacter);                  break;               case '+': case '-': case '*': case '/':                  while (!done && !operatorStack.isEmpty())                  {                     topOperator = operatorStack.peek();                     if (getPrecedence(nextCharacter) <= getPrecedence(topOperator))                     {                        postfix = postfix.append(topOperator);                        operatorStack.pop();                     }                     else                        done = true;                  } // end while                  operatorStack.push(nextCharacter);                  break;               case '(':                  operatorStack.push(nextCharacter);               break;               case ')': // Stack is not empty if infix expression is valid                  topOperator = operatorStack.pop();                  while (topOperator != '(')                  {                     postfix = postfix.append(topOperator);                     topOperator = operatorStack.pop();                  } // end while                  break;               default: break; // Ignore unexpected characters            } // end switch         } // end if      } // end for      while (!operatorStack.isEmpty())      {         topOperator = operatorStack.pop();         postfix = postfix.append(topOperator);      } // end while      return postfix.toString();   } // end convertToPostfix   // Indicates the precedence of a given operator.   // Precondition: operator is a character that is (, ), +, -, *, /, or ^.   // Returns an integer that indicates the precedence of operator:   //         0 if ( or ), 1 if + or -, 2 if * or /, 3 if ^,   //         -1 if anything else. */   private static int getPrecedence(char operator)   {      switch (operator)      {         case '(': case ')': return 0;         case '+': case '-': return 1;         case '*': case '/': return 2;         case '^':           return 3;      } // end switch      return -1;   } // end getPrecedence   private static boolean isVariable(char character)   {      return Character.isLetter(character);   } // end isVariable   private static boolean isInteger(char character){return Character.isDigit(character);}   /** Evaluates a postfix expression.       Segment 5.18       @param postfix  a string that is a valid postfix expression.       @return  the value of the postfix expression. */   public static double evaluatePostfix(String postfix)   {      StackInterface<Double> valueStack = new ArrayStack<Double>();      int characterCount = postfix.length();      for (int index = 0; index < characterCount; index++)      {         char nextCharacter = postfix.charAt(index);         switch(nextCharacter)         {            case 'a': case 'b': case 'c': case 'd': case 'e':case 'f': case 'g':case 'h':               valueStack.push(valueOf(nextCharacter));               break;            case '+': case '-': case '*': case '/': case '^':               Double operandTwo = valueStack.pop();               Double operandOne = valueStack.pop();               Double result = compute(operandOne, operandTwo, nextCharacter);               valueStack.push(result);               break;            default: break; // Ignore unexpected characters         } // end switch      } // end for      return (valueStack.peek());   } // end evaluatePostfix   private static double valueOf(char variable)   {      switch (variable)      {         case 'a': return 2;         case 'b': return 3;         case 'c': return 4;         case 'd': return 5;         case 'e': return 6;         case 'f': return 0;         case 'g': return 1;         case 'h': return 8;      } // end switch      return 0; // Unexpected character   } // end valueOf   private static Double compute(Double operandOne, Double operandTwo, char operator)   {      double result;      switch (operator)      {         case '+':            result = operandOne + operandTwo;            break;         case '-':            result = operandOne - operandTwo;            break;         case '*':            result = operandOne * operandTwo;             break;         case '/':            result = operandOne / operandTwo;            break;         case '^':            result = Math.pow(operandOne, operandTwo);            break;         default:    // Unexpected character            result = 0;            break;      } // end switch      return result;   } // end compute   public static char characterChange(char nextCharacter){      switch(nextCharacter)      {         case '2': nextCharacter='a';            break;         case '3': nextCharacter='b';            break;         case '4': nextCharacter='c';            break;         case '5': nextCharacter='d';            break;         case '6': nextCharacter='e';            break;         case '0': nextCharacter='f';            break;         case '1': nextCharacter='g';            break;         case '8': nextCharacter='h';         default:break;      }      return nextCharacter;   }} // end Postfix